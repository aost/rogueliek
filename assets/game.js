/* Generated by Opal 0.7.0.beta1 */
Opal.modules["input"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$reset', '$include?', '$values', '$[]=', '$==', '$[]']);
  return (function($base, $super) {
    function $Input(){};
    var self = $Input = $klass($base, $super, 'Input', $Input);

    var def = self.$$proto, $scope = self.$$scope;

    def.input = nil;
    def.$initialize = function() {
      var self = this;

      return self.$reset();
    };

    def.$reset = function() {
      var self = this;

      return self.input = $hash2([], {});
    };

    def['$any?'] = function() {
      var self = this;

      return self.input.$values()['$include?'](true);
    };

    def.$up = function() {
      var self = this;

      return self.input['$[]=']("up", true);
    };

    def['$up?'] = function() {
      var self = this;

      return self.input['$[]']("up")['$=='](true);
    };

    def.$down = function() {
      var self = this;

      return self.input['$[]=']("down", true);
    };

    def['$down?'] = function() {
      var self = this;

      return self.input['$[]']("down")['$=='](true);
    };

    def.$left = function() {
      var self = this;

      return self.input['$[]=']("left", true);
    };

    def['$left?'] = function() {
      var self = this;

      return self.input['$[]']("left")['$=='](true);
    };

    def.$right = function() {
      var self = this;

      return self.input['$[]=']("right", true);
    };

    return (def['$right?'] = function() {
      var self = this;

      return self.input['$[]']("right")['$=='](true);
    }, nil) && 'right?';
  })(self, null)
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["thing"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$attr_accessor']);
  return (function($base, $super) {
    function $Thing(){};
    var self = $Thing = $klass($base, $super, 'Thing', $Thing);

    var def = self.$$proto, $scope = self.$$scope;

    self.$attr_accessor("x", "y");

    def.$initialize = function(x, y) {
      var $a, self = this;

      return $a = [x, y], self.x = $a[0], self.y = $a[1];
    };

    def.$update = function(game, scene, elapsed) {
      var self = this;

      return nil;
    };

    def.$draw = function(display) {
      var self = this;

      return nil;
    };

    def['$pushable?'] = function() {
      var self = this;

      return false;
    };

    return (def['$good?'] = function() {
      var self = this;

      return false;
    }, nil) && 'good?';
  })(self, null)
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["wall"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$require', '$[]', '$fill_color=', '$fill_rectangle']);
  self.$require("thing");
  return (function($base, $super) {
    function $Wall(){};
    var self = $Wall = $klass($base, $super, 'Wall', $Wall);

    var def = self.$$proto, $scope = self.$$scope;

    def.x = def.y = nil;
    $opal.cdecl($scope, 'COLOR', $scope.get('Color')['$[]'](40, 40, 60));

    return (def.$draw = function(display) {
      var $a, $b, self = this;

      (($a = [$scope.get('COLOR')]), $b = display, $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      return display.$fill_rectangle($rb_times(self.x, 64), $rb_times(self.y, 64), 64, 64);
    }, nil) && 'draw';
  })(self, $scope.get('Thing'));
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["boulder"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$require', '$[]', '$fill_color=', '$fill_ellipse']);
  self.$require("thing");
  return (function($base, $super) {
    function $Boulder(){};
    var self = $Boulder = $klass($base, $super, 'Boulder', $Boulder);

    var def = self.$$proto, $scope = self.$$scope;

    def.x = def.y = nil;
    $opal.cdecl($scope, 'COLOR', $scope.get('Color')['$[]'](160, 160, 160));

    def.$draw = function(display) {
      var $a, $b, self = this;

      (($a = [$scope.get('COLOR')]), $b = display, $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      return display.$fill_ellipse($rb_plus($rb_times(self.x, 64), 32), $rb_plus($rb_times(self.y, 64), 32), 24, 24);
    };

    return (def['$pushable?'] = function() {
      var self = this;

      return true;
    }, nil) && 'pushable?';
  })(self, $scope.get('Thing'));
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["actor"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $range = $opal.range;

  $opal.add_stubs(['$require', '$[]', '$attr_accessor', '$max_health', '$lose', '$movement', '$zero?', '$find_collision', '$nil?', '$x=', '$x', '$y=', '$y', '$respond_to?', '$health=', '$health', '$rand', '$last', '$attack_range', '$first', '$pushable?', '$fill_color=', '$fill_ellipse', '$color']);
  self.$require("thing");
  return (function($base, $super) {
    function $Actor(){};
    var self = $Actor = $klass($base, $super, 'Actor', $Actor);

    var def = self.$$proto, $scope = self.$$scope, TMP_1;

    def.health = def.x = def.y = def.color = nil;
    $opal.cdecl($scope, 'DEATH_COLOR', $scope.get('Color')['$[]'](222, 222, 222));

    self.$attr_accessor("health");

    def.$initialize = TMP_1 = function(x, y) {var $zuper = $slice.call(arguments, 0);
      var self = this, $iter = TMP_1.$$p, $yield = $iter || nil;

      TMP_1.$$p = null;
      $opal.find_super_dispatcher(self, 'initialize', TMP_1, $iter).apply(self, $zuper);
      return self.health = self.$max_health();
    };

    def.$movement = function(scene) {
      var self = this;

      return [0, 0];
    };

    def.$update = function(game, space, elapsed) {
      var self = this;

      if ($rb_le(self.health, 0)) {
        return game.$lose()
        } else {
        return nil
      };
    };

    def.$move = function(game, scene) {
      var $a, $b, self = this, move_x = nil, move_y = nil, collidee = nil, collidee_collidee = nil;

      $a = $opal.to_ary(self.$movement(game, scene)), move_x = ($a[0] == null ? nil : $a[0]), move_y = ($a[1] == null ? nil : $a[1]);
      if ((($a = ($b = move_x['$zero?'](), $b !== false && $b !== nil ?move_y['$zero?']() : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
        return nil};
      collidee = scene.$find_collision(self, $rb_plus(self.x, move_x), $rb_plus(self.y, move_y));
      if ((($a = collidee['$nil?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        ($a = self, $a['$x=']($rb_plus($a.$x(), move_x)));
        return ($a = self, $a['$y=']($rb_plus($a.$y(), move_y)));
        } else {
        collidee_collidee = scene.$find_collision(collidee, $rb_plus(collidee.$x(), move_x), $rb_plus(collidee.$y(), move_y));
        if ((($a = collidee['$respond_to?']("health")) !== nil && (!$a.$$is_boolean || $a == true))) {
          ($a = collidee, $a['$health=']($rb_minus($a.$health(), $rb_plus(self.$rand(self.$attack_range().$last()), self.$attack_range().$first()))));
          if ($rb_lt(collidee.$health(), 0)) {
            return (($a = [0]), $b = collidee, $b['$health='].apply($b, $a), $a[$a.length-1])
            } else {
            return nil
          };
        } else if ((($a = ($b = collidee['$pushable?'](), $b !== false && $b !== nil ?collidee_collidee['$nil?']() : $b)) !== nil && (!$a.$$is_boolean || $a == true))) {
          ($a = collidee, $a['$x=']($rb_plus($a.$x(), move_x)));
          ($a = collidee, $a['$y=']($rb_plus($a.$y(), move_y)));
          ($a = self, $a['$x=']($rb_plus($a.$x(), move_x)));
          return ($a = self, $a['$y=']($rb_plus($a.$y(), move_y)));
          } else {
          return nil
        };
      };
    };

    def.$draw = function(display) {
      var $a, $b, self = this, health_percent = nil;

      (($a = [$scope.get('DEATH_COLOR')]), $b = display, $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      display.$fill_ellipse($rb_plus($rb_times(self.x, 64), 32), $rb_plus($rb_times(self.y, 64), 32), 23, 23);
      health_percent = $rb_divide(self.health, self.$max_health());
      (($a = [self.$color()]), $b = display, $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      return display.$fill_ellipse($rb_plus($rb_times(self.x, 64), 32), $rb_plus($rb_times(self.y, 64), 32), $rb_times(24, health_percent), $rb_times(24, health_percent));
    };

    def.$max_health = function() {
      var self = this;

      return 1;
    };

    def.$attack_range = function() {
      var self = this;

      return ($range(0, 1, false));
    };

    return (def.$color = function() {
      var $a, self = this;

      return ((($a = self.color) !== false && $a !== nil) ? $a : self.color = $scope.get('Color')['$[]'](0, 0, 0));
    }, nil) && 'color';
  })(self, $scope.get('Thing'));
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["hero"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $range = $opal.range;

  $opal.add_stubs(['$require', '$new_turn?', '$move', '$lose', '$right?', '$input', '$left?', '$down?', '$up?', '$[]']);
  self.$require("actor");
  return (function($base, $super) {
    function $Hero(){};
    var self = $Hero = $klass($base, $super, 'Hero', $Hero);

    var def = self.$$proto, $scope = self.$$scope;

    def.health = def.color = nil;
    def.$update = function(game, scene, elapsed) {
      var $a, self = this;

      if ((($a = scene['$new_turn?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.$move(game, scene)};
      if ($rb_le(self.health, 0)) {
        return scene.$lose(game)
        } else {
        return nil
      };
    };

    def.$movement = function(game, scene) {
      var $a, self = this, move_x = nil, move_y = nil;

      move_x = move_y = 0;
      if ((($a = game.$input()['$right?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        move_x = $rb_plus(move_x, 1)};
      if ((($a = game.$input()['$left?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        move_x = $rb_minus(move_x, 1)};
      if ((($a = game.$input()['$down?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        move_y = $rb_plus(move_y, 1)};
      if ((($a = game.$input()['$up?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        move_y = $rb_minus(move_y, 1)};
      return [move_x, move_y];
    };

    def.$max_health = function() {
      var self = this;

      return 10;
    };

    def.$attack_range = function() {
      var self = this;

      return ($range(1, 3, false));
    };

    def['$good?'] = function() {
      var self = this;

      return true;
    };

    return (def.$color = function() {
      var $a, self = this;

      return ((($a = self.color) !== false && $a !== nil) ? $a : self.color = $scope.get('Color')['$[]'](150, 50, 50));
    }, nil) && 'color';
  })(self, $scope.get('Actor'));
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["baddie"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $range = $opal.range;

  $opal.add_stubs(['$require', '$new_turn?', '$move', '$win', '$find', '$to_proc', '$things', '$nil?', '$x', '$y', '$[]']);
  self.$require("actor");
  return (function($base, $super) {
    function $Baddie(){};
    var self = $Baddie = $klass($base, $super, 'Baddie', $Baddie);

    var def = self.$$proto, $scope = self.$$scope;

    def.health = def.color = nil;
    def.$update = function(game, scene, elapsed) {
      var $a, self = this;

      if ((($a = scene['$new_turn?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.$move(game, scene)};
      if ($rb_le(self.health, 0)) {
        return scene.$win(game)
        } else {
        return nil
      };
    };

    def.$movement = function(game, scene) {
      var $a, $b, self = this, target = nil, move_x = nil, move_y = nil;

      target = ($a = ($b = scene.$things()).$find, $a.$$p = "good?".$to_proc(), $a).call($b);
      if ((($a = target['$nil?']()) !== nil && (!$a.$$is_boolean || $a == true))) {
        return [0, 0]};
      move_x = move_y = 0;
      if ($rb_gt(target.$x(), self.$x())) {
        move_x = $rb_plus(move_x, 1)};
      if ($rb_lt(target.$x(), self.$x())) {
        move_x = $rb_minus(move_x, 1)};
      if ($rb_gt(target.$y(), self.$y())) {
        move_y = $rb_plus(move_y, 1)};
      if ($rb_lt(target.$y(), self.$y())) {
        move_y = $rb_minus(move_y, 1)};
      return [move_x, move_y];
    };

    def.$max_health = function() {
      var self = this;

      return 12;
    };

    def.$attack_range = function() {
      var self = this;

      return ($range(1, 4, false));
    };

    return (def.$color = function() {
      var $a, self = this;

      return ((($a = self.color) !== false && $a !== nil) ? $a : self.color = $scope.get('Color')['$[]'](50, 150, 50));
    }, nil) && 'color';
  })(self, $scope.get('Actor'));
};

/* Generated by Opal 0.7.0.beta1 */
Opal.modules["scene"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $range = $opal.range;

  $opal.add_stubs(['$require', '$[]', '$attr_reader', '$times', '$<<', '$new', '$each', '$rand', '$nil?', '$find_collision', '$any?', '$input', '$update', '$fill_color=', '$display', '$clear', '$draw', '$tick_count', '$ticker', '$initialize', '$find', '$is_a?', '$things', '$health=', '$health', '$==', '$x', '$y']);
  self.$require("wall");
  self.$require("boulder");
  self.$require("hero");
  self.$require("baddie");
  return (function($base, $super) {
    function $Scene(){};
    var self = $Scene = $klass($base, $super, 'Scene', $Scene);

    var def = self.$$proto, $scope = self.$$scope;

    def.things = def.lost_tick = def.won_tick = def.new_turn = nil;
    $opal.cdecl($scope, 'COLOR', $scope.get('Color')['$[]'](50, 50, 50));

    self.$attr_reader("things");

    def.$initialize = function() {
      var $a, $b, TMP_1, $c, TMP_2, self = this;

      $a = [640, 640], self.width = $a[0], self.height = $a[1];
      self.things = [];
      ($a = ($b = (10)).$times, $a.$$p = (TMP_1 = function(n){var self = TMP_1.$$s || this;
        if (self.things == null) self.things = nil;
if (n == null) n = nil;
      self.things['$<<']($scope.get('Wall').$new(0, n));
        self.things['$<<']($scope.get('Wall').$new(9, n));
        self.things['$<<']($scope.get('Wall').$new(n, 0));
        return self.things['$<<']($scope.get('Wall').$new(n, 9));}, TMP_1.$$s = self, TMP_1), $a).call($b);
      return ($a = ($c = [$scope.get('Boulder'), $scope.get('Boulder'), $scope.get('Boulder'), $scope.get('Baddie'), $scope.get('Hero')]).$each, $a.$$p = (TMP_2 = function(thing){var self = TMP_2.$$s || this, $a, $b, x = nil, y = nil;
        if (self.things == null) self.things = nil;
if (thing == null) thing = nil;
      x = self.$rand($range(1, 8, false));
        y = self.$rand($range(1, 8, false));
        while (!((($b = self.$find_collision(nil, x, y)['$nil?']()) !== nil && (!$b.$$is_boolean || $b == true)))) {
        x = self.$rand($range(1, 8, false));
        y = self.$rand($range(1, 8, false));};
        return self.things['$<<'](thing.$new(x, y));}, TMP_2.$$s = self, TMP_2), $a).call($c);
    };

    def.$update = function(game, elapsed) {
      var $a, $b, TMP_3, self = this;

      self.new_turn = game.$input()['$any?']();
      return ($a = ($b = self.things).$each, $a.$$p = (TMP_3 = function(t){var self = TMP_3.$$s || this;
if (t == null) t = nil;
      return t.$update(game, self, elapsed)}, TMP_3.$$s = self, TMP_3), $a).call($b);
    };

    def.$draw = function(game) {
      var $a, $b, TMP_4, $c, TMP_5, self = this, ticks = nil, hero = nil;

      (($a = [$scope.get('COLOR')]), $b = game.$display(), $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
      game.$display().$clear();
      ($a = ($b = self.things).$each, $a.$$p = (TMP_4 = function(t){var self = TMP_4.$$s || this;
if (t == null) t = nil;
      return t.$draw(game.$display())}, TMP_4.$$s = self, TMP_4), $a).call($b);
      if ((($a = self.lost_tick) !== nil && (!$a.$$is_boolean || $a == true))) {
        if ($rb_lt($rb_minus(game.$ticker().$tick_count(), self.lost_tick), 100)) {
          (($a = [$scope.get('Color')['$[]'](0, 0, 0)]), $c = game.$display(), $c['$fill_color='].apply($c, $a), $a[$a.length-1]);
          return game.$display().$clear();
          } else {
          self.$initialize();
          return self.lost_tick = nil;
        }
      } else if ((($a = self.won_tick) !== nil && (!$a.$$is_boolean || $a == true))) {
        ticks = $rb_minus(game.$ticker().$tick_count(), self.won_tick);
        hero = ($a = ($c = self.$things()).$find, $a.$$p = (TMP_5 = function(t){var self = TMP_5.$$s || this;
if (t == null) t = nil;
        return t['$is_a?']($scope.get('Hero'))}, TMP_5.$$s = self, TMP_5), $a).call($c);
        return ($a = hero, $a['$health=']($rb_plus($a.$health(), 2)));
        } else {
        return nil
      };
    };

    def.$find_collision = function(t, x, y) {
      var $a, $b, TMP_6, self = this;

      return ($a = ($b = self.things).$find, $a.$$p = (TMP_6 = function(thing){var self = TMP_6.$$s || this, $a;
if (thing == null) thing = nil;
      if (thing['$=='](t)) {
          return nil;};
        return (($a = thing.$x()['$=='](x)) ? thing.$y()['$=='](y) : $a);}, TMP_6.$$s = self, TMP_6), $a).call($b);
    };

    def['$new_turn?'] = function() {
      var self = this;

      return self.new_turn;
    };

    def.$win = function(game) {
      var $a, self = this;

      return ((($a = self.won_tick) !== false && $a !== nil) ? $a : self.won_tick = game.$ticker().$tick_count());
    };

    return (def.$lose = function(game) {
      var $a, self = this;

      return ((($a = self.lost_tick) !== false && $a !== nil) ? $a : self.lost_tick = game.$ticker().$tick_count());
    }, nil) && 'lose';
  })(self, null);
};

/* Generated by Opal 0.7.0.beta1 */
(function($opal) {
  $opal.dynamic_require_severity = "error";
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$require', '$attr_reader', '$size=', '$display', '$new', '$pressed?', '$keyboard', '$up', '$down', '$left', '$right', '$update', '$draw', '$pressing?', '$fill_color=', '$[]', '$fill_text', '$ticks_per_second', '$ticker', '$width', '$reset']);
  self.$require("input");
  self.$require("scene");
  return (function($base, $super) {
    function $Rogueliek(){};
    var self = $Rogueliek = $klass($base, $super, 'Rogueliek', $Rogueliek);

    var def = self.$$proto, $scope = self.$$scope;

    def.input = def.scene = nil;
    self.$attr_reader("input");

    def.$setup = function() {
      var $a, $b, self = this;

      (($a = [[640, 640]]), $b = self.$display(), $b['$size='].apply($b, $a), $a[$a.length-1]);
      self.input = $scope.get('Input').$new();
      return self.scene = $scope.get('Scene').$new();
    };

    return (def.$update = function(elapsed) {
      var $a, $b, self = this;

      if ((($a = self.$keyboard()['$pressed?']("up")) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.input.$up()};
      if ((($a = self.$keyboard()['$pressed?']("down")) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.input.$down()};
      if ((($a = self.$keyboard()['$pressed?']("left")) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.input.$left()};
      if ((($a = self.$keyboard()['$pressed?']("right")) !== nil && (!$a.$$is_boolean || $a == true))) {
        self.input.$right()};
      self.scene.$update(self, elapsed);
      self.scene.$draw(self);
      if ((($a = self.$keyboard()['$pressing?']("f")) !== nil && (!$a.$$is_boolean || $a == true))) {
        (($a = [$scope.get('Color')['$[]'](255, 255, 255)]), $b = self.$display(), $b['$fill_color='].apply($b, $a), $a[$a.length-1]);
        self.$display().$fill_text(self.$ticker().$ticks_per_second(), $rb_minus(self.$display().$width(), 32), 32);};
      return self.input.$reset();
    }, nil) && 'update';
  })(self, $scope.get('Game'));
})(Opal);

//# sourceMappingURL=game.map
;
